#  다이나믹 프로그래밍

**2020.October.01**



## 다이나믹 프로그래밍

* 큰 문제를 작은 문제로 나눠서 푸는 알고리즘.
  * DP : 중복 있
  * 분할 정복 : 중복 없



* 푸는 방법
  * overlapping subproblem
    * 큰문제와 작은문제를 같은 방법으로 풀 수 있다.
  * Optimal substructure
    * 문제의 정답을 작은 문제의 정답에서 구할 수 있다.



* 구현 방식
  * Top-down : 재귀
  * Bottom-up : 문제를 크기가 작은 문제부터 차례대로 푼다. - 반복문





## 1,2,3 더하기까지

### 1로 만들기

> 백준 1463, BJ15988,

* D[N] = N을 1로 만드는 최소 연산 횟수

```java
int go(int n){
  if(n == 1) return 0;
  if(d[n] > 0) return d[n];
  d[n] = go(n-1)+1;
  if(n%2 == 0){
    int temp = go(n/2) +1;
    if(d[n]>temp) d[n]=temp;
  }
  if(n%3 == 0){
    int temp = go(n/3)+1;
    if(d[n]>temp)
      d[n] = temp;
  }
  return d[n];
}
```

n%3, n%2, -1 순서대로 경우의수 최솟값 구하라했는데  반대 순서로 놔둠 Why?   

​	=> 첫순서에서 먼저 구하고 비교를 계속 사용하는 방식



```java
d[1]=0;
for(int i=2; i<=n; i++){
  d[i] = d[i-1] +1; 							//n -> (n-1)
  if(i%2 == 0 && d[i] > d[i/2] +1){
    d[i] = d[i/2] +1;							//n -> (n/2)
  }
  if(i%3 == 0 && d[i] > d[i/3] +1){
    d[i] = d[i/3] +1;							//n -> (n/3)
  }
}
```







## 이친수까지

점화식으로 해결





## 합분해

### 가장 긴 증가하는 부분 수열 (LIS)

>  백준 11053



### 제곱수의 합

D[N]= min(D[N=i^2])+1





## 연습문제

> 백준 15988

